/**
 * BitMEX API
 * ## REST API for the BitMEX Trading Platform  _If you are building automated tools, please subscribe to the_ _[BitMEX API RSS Feed](https://blog.bitmex.com/api_announcement/feed/) for changes. The feed will be updated_ _regularly and is the most reliable way to get downtime and update announcements._  [View Changelog](/app/apiChangelog)  ---  #### Getting Started  Base URI: [https://www.bitmex.com/api/v1](/api/v1)  ##### Fetching Data  All REST endpoints are documented below. You can try out any query right from this interface.  Most table queries accept `count`, `start`, and `reverse` params. Set `reverse=true` to get rows newest-first.  Additional documentation regarding filters, timestamps, and authentication is available in [the main API documentation](/app/restAPI).  _All_ table data is available via the [Websocket](/app/wsAPI). We highly recommend using the socket if you want to have the quickest possible data without being subject to ratelimits.  ##### Return Types  By default, all data is returned as JSON. Send `?_format=csv` to get CSV data or `?_format=xml` to get XML data.  ##### Trade Data Queries  _This is only a small subset of what is available, to get you started._  Fill in the parameters and click the `Try it out!` button to try any of these queries.  - [Pricing Data](#!/Quote/Quote_get)  - [Trade Data](#!/Trade/Trade_get)  - [OrderBook Data](#!/OrderBook/OrderBook_getL2)  - [Settlement Data](#!/Settlement/Settlement_get)  - [Exchange Statistics](#!/Stats/Stats_history)  Every function of the BitMEX.com platform is exposed here and documented. Many more functions are available.  ##### Swagger Specification  [â‡© Download Swagger JSON](swagger.json)  ---  ## All API Endpoints  Click to expand a section. 
 *
 * OpenAPI spec version: 1.2.0
 * Contact: support@bitmex.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.AccessToken
import io.swagger.client.model.Affiliate
import io.swagger.client.model.CommunicationToken
import java.util.Date
import io.swagger.client.model.Error
import io.swagger.client.model.Margin
import io.swagger.client.model.Number
import io.swagger.client.model.QuoteFillRatio
import io.swagger.client.model.QuoteValueRatio
import io.swagger.client.model.TradingVolume
import io.swagger.client.model.Transaction
import io.swagger.client.model.User
import io.swagger.client.model.UserCommissionsBySymbol
import io.swagger.client.model.Wallet
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class UserApi(
  val defBasePath: String = "https://www.bitmex.com/api/v1",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new UserApiAsyncHelper(client, config)

  /**
   * Cancel a withdrawal.
   * 
   *
   * @param token  
   * @return Transaction
   */
  def userCancelWithdrawal(token: String): Option[Transaction] = {
    val await = Try(Await.result(userCancelWithdrawalAsync(token), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Cancel a withdrawal. asynchronously
   * 
   *
   * @param token  
   * @return Future(Transaction)
   */
  def userCancelWithdrawalAsync(token: String): Future[Transaction] = {
      helper.userCancelWithdrawal(token)
  }

  /**
   * Check if a referral code is valid.
   * If the code is valid, responds with the referral code&#39;s discount (e.g. &#x60;0.1&#x60; for 10%). Otherwise, will return a 404 or 451 if invalid.
   *
   * @param referralCode  (optional)
   * @return Double
   */
  def userCheckReferralCode(referralCode: Option[String] = None): Option[Double] = {
    val await = Try(Await.result(userCheckReferralCodeAsync(referralCode), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Check if a referral code is valid. asynchronously
   * If the code is valid, responds with the referral code&#39;s discount (e.g. &#x60;0.1&#x60; for 10%). Otherwise, will return a 404 or 451 if invalid.
   *
   * @param referralCode  (optional)
   * @return Future(Double)
   */
  def userCheckReferralCodeAsync(referralCode: Option[String] = None): Future[Double] = {
      helper.userCheckReferralCode(referralCode)
  }

  /**
   * Register your communication token for mobile clients
   * 
   *
   * @param token  
   * @param platformAgent  
   * @return List[CommunicationToken]
   */
  def userCommunicationToken(token: String, platformAgent: String): Option[List[CommunicationToken]] = {
    val await = Try(Await.result(userCommunicationTokenAsync(token, platformAgent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Register your communication token for mobile clients asynchronously
   * 
   *
   * @param token  
   * @param platformAgent  
   * @return Future(List[CommunicationToken])
   */
  def userCommunicationTokenAsync(token: String, platformAgent: String): Future[List[CommunicationToken]] = {
      helper.userCommunicationToken(token, platformAgent)
  }

  /**
   * Confirm your email address with a token.
   * 
   *
   * @param token  
   * @return AccessToken
   */
  def userConfirm(token: String): Option[AccessToken] = {
    val await = Try(Await.result(userConfirmAsync(token), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Confirm your email address with a token. asynchronously
   * 
   *
   * @param token  
   * @return Future(AccessToken)
   */
  def userConfirmAsync(token: String): Future[AccessToken] = {
      helper.userConfirm(token)
  }

  /**
   * Confirm a withdrawal.
   * 
   *
   * @param token  
   * @return Transaction
   */
  def userConfirmWithdrawal(token: String): Option[Transaction] = {
    val await = Try(Await.result(userConfirmWithdrawalAsync(token), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Confirm a withdrawal. asynchronously
   * 
   *
   * @param token  
   * @return Future(Transaction)
   */
  def userConfirmWithdrawalAsync(token: String): Future[Transaction] = {
      helper.userConfirmWithdrawal(token)
  }

  /**
   * Get your user model.
   * 
   *
   * @return User
   */
  def userGet(): Option[User] = {
    val await = Try(Await.result(userGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your user model. asynchronously
   * 
   *
   * @return Future(User)
   */
  def userGetAsync(): Future[User] = {
      helper.userGet()
  }

  /**
   * Get your current affiliate/referral status.
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Affiliate
   */
  def userGetAffiliateStatus(currency: Option[String] = Option("XBt")): Option[Affiliate] = {
    val await = Try(Await.result(userGetAffiliateStatusAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your current affiliate/referral status. asynchronously
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Future(Affiliate)
   */
  def userGetAffiliateStatusAsync(currency: Option[String] = Option("XBt")): Future[Affiliate] = {
      helper.userGetAffiliateStatus(currency)
  }

  /**
   * Get your account&#39;s commission status.
   * 
   *
   * @return UserCommissionsBySymbol
   */
  def userGetCommission(): Option[UserCommissionsBySymbol] = {
    val await = Try(Await.result(userGetCommissionAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your account&#39;s commission status. asynchronously
   * 
   *
   * @return Future(UserCommissionsBySymbol)
   */
  def userGetCommissionAsync(): Future[UserCommissionsBySymbol] = {
      helper.userGetCommission()
  }

  /**
   * Get a deposit address.
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60; (optional, default to XBt)
   * @return String
   */
  def userGetDepositAddress(currency: Option[String] = Option("XBt")): Option[String] = {
    val await = Try(Await.result(userGetDepositAddressAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a deposit address. asynchronously
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60; (optional, default to XBt)
   * @return Future(String)
   */
  def userGetDepositAddressAsync(currency: Option[String] = Option("XBt")): Future[String] = {
      helper.userGetDepositAddress(currency)
  }

  /**
   * Get the execution history by day.
   * 
   *
   * @param symbol  
   * @param timestamp  
   * @return Any
   */
  def userGetExecutionHistory(symbol: String = "XBTUSD", timestamp: Date = dateTimeFormatter.parse("2017-02-13T12:00:00.000Z")): Option[Any] = {
    val await = Try(Await.result(userGetExecutionHistoryAsync(symbol, timestamp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the execution history by day. asynchronously
   * 
   *
   * @param symbol  
   * @param timestamp  
   * @return Future(Any)
   */
  def userGetExecutionHistoryAsync(symbol: String = "XBTUSD", timestamp: Date = dateTimeFormatter.parse("2017-02-13T12:00:00.000Z")): Future[Any] = {
      helper.userGetExecutionHistory(symbol, timestamp)
  }

  /**
   * Get your account&#39;s margin status. Send a currency of \&quot;all\&quot; to receive an array of all supported currencies.
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Margin
   */
  def userGetMargin(currency: Option[String] = Option("XBt")): Option[Margin] = {
    val await = Try(Await.result(userGetMarginAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your account&#39;s margin status. Send a currency of \&quot;all\&quot; to receive an array of all supported currencies. asynchronously
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Future(Margin)
   */
  def userGetMarginAsync(currency: Option[String] = Option("XBt")): Future[Margin] = {
      helper.userGetMargin(currency)
  }

  /**
   * Get 7 days worth of Quote Fill Ratio statistics.
   * 
   *
   * @return QuoteFillRatio
   */
  def userGetQuoteFillRatio(): Option[QuoteFillRatio] = {
    val await = Try(Await.result(userGetQuoteFillRatioAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get 7 days worth of Quote Fill Ratio statistics. asynchronously
   * 
   *
   * @return Future(QuoteFillRatio)
   */
  def userGetQuoteFillRatioAsync(): Future[QuoteFillRatio] = {
      helper.userGetQuoteFillRatio()
  }

  /**
   * Get Quote Value Ratio statistics over the last 3 days
   * 
   *
   * @return QuoteValueRatio
   */
  def userGetQuoteValueRatio(): Option[QuoteValueRatio] = {
    val await = Try(Await.result(userGetQuoteValueRatioAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Quote Value Ratio statistics over the last 3 days asynchronously
   * 
   *
   * @return Future(QuoteValueRatio)
   */
  def userGetQuoteValueRatioAsync(): Future[QuoteValueRatio] = {
      helper.userGetQuoteValueRatio()
  }

  /**
   * Get your 30 days USD average trading volume
   * 
   *
   * @return TradingVolume
   */
  def userGetTradingVolume(): Option[TradingVolume] = {
    val await = Try(Await.result(userGetTradingVolumeAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your 30 days USD average trading volume asynchronously
   * 
   *
   * @return Future(TradingVolume)
   */
  def userGetTradingVolumeAsync(): Future[TradingVolume] = {
      helper.userGetTradingVolume()
  }

  /**
   * Get your current wallet information.
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Wallet
   */
  def userGetWallet(currency: Option[String] = Option("XBt")): Option[Wallet] = {
    val await = Try(Await.result(userGetWalletAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your current wallet information. asynchronously
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Future(Wallet)
   */
  def userGetWalletAsync(currency: Option[String] = Option("XBt")): Future[Wallet] = {
      helper.userGetWallet(currency)
  }

  /**
   * Get a history of all of your wallet transactions (deposits, withdrawals, PNL).
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @param count Number of results to fetch. (optional, default to 100)
   * @param start Starting point for results. (optional, default to 0)
   * @return List[Transaction]
   */
  def userGetWalletHistory(currency: Option[String] = Option("XBt"), count: Option[Double] = Option(100), start: Option[Double] = Option(0)): Option[List[Transaction]] = {
    val await = Try(Await.result(userGetWalletHistoryAsync(currency, count, start), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a history of all of your wallet transactions (deposits, withdrawals, PNL). asynchronously
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @param count Number of results to fetch. (optional, default to 100)
   * @param start Starting point for results. (optional, default to 0)
   * @return Future(List[Transaction])
   */
  def userGetWalletHistoryAsync(currency: Option[String] = Option("XBt"), count: Option[Double] = Option(100), start: Option[Double] = Option(0)): Future[List[Transaction]] = {
      helper.userGetWalletHistory(currency, count, start)
  }

  /**
   * Get a summary of all of your wallet transactions (deposits, withdrawals, PNL).
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return List[Transaction]
   */
  def userGetWalletSummary(currency: Option[String] = Option("XBt")): Option[List[Transaction]] = {
    val await = Try(Await.result(userGetWalletSummaryAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a summary of all of your wallet transactions (deposits, withdrawals, PNL). asynchronously
   * 
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60;, &#x60;all&#x60; (optional, default to XBt)
   * @return Future(List[Transaction])
   */
  def userGetWalletSummaryAsync(currency: Option[String] = Option("XBt")): Future[List[Transaction]] = {
      helper.userGetWalletSummary(currency)
  }

  /**
   * Log out of BitMEX.
   * 
   *
   * @return void
   */
  def userLogout() = {
    val await = Try(Await.result(userLogoutAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Log out of BitMEX. asynchronously
   * 
   *
   * @return Future(void)
   */
  def userLogoutAsync() = {
      helper.userLogout()
  }

  /**
   * Get the minimum, maximum, and recommended withdrawal fees for a currency.
   * This is changed based on network conditions to ensure timely withdrawals. During network congestion, this may be high. The fee is returned in the same currency.  The \&quot;fee\&quot; field is the recommended fee for fast confirmation on the blockchain.
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60; (optional, default to XBt)
   * @param amount  (optional)
   * @return Any
   */
  def userMinWithdrawalFee(currency: Option[String] = Option("XBt"), amount: Option[Double] = None): Option[Any] = {
    val await = Try(Await.result(userMinWithdrawalFeeAsync(currency, amount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the minimum, maximum, and recommended withdrawal fees for a currency. asynchronously
   * This is changed based on network conditions to ensure timely withdrawals. During network congestion, this may be high. The fee is returned in the same currency.  The \&quot;fee\&quot; field is the recommended fee for fast confirmation on the blockchain.
   *
   * @param currency Options: &#x60;XBt&#x60;, &#x60;USDt&#x60; (optional, default to XBt)
   * @param amount  (optional)
   * @return Future(Any)
   */
  def userMinWithdrawalFeeAsync(currency: Option[String] = Option("XBt"), amount: Option[Double] = None): Future[Any] = {
      helper.userMinWithdrawalFee(currency, amount)
  }

  /**
   * Request a withdrawal to an external wallet.
   * This will send a confirmation email to the email address on record.
   *
   * @param currency Currency you&#39;re withdrawing. Options: &#x60;XBt&#x60;, &#x60;USDt&#x60; 
   * @param amount Amount of withdrawal currency. 
   * @param otpToken 2FA token. Required for all external withdrawals. (optional)
   * @param address Destination Address. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param addressId ID of the Destination Address. One of &#x60;address&#x60;, &#x60;targetUserId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param targetUserId ID of the Target User. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param fee Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email. (optional)
   * @param text Optional annotation, e.g. &#39;Transfer to home wallet&#39;. (optional)
   * @return Transaction
   */
  def userRequestWithdrawal(currency: String = "XBt", amount: Number, otpToken: Option[String] = None, address: Option[String] = None, addressId: Option[Double] = None, targetUserId: Option[Double] = None, fee: Option[Double] = None, text: Option[String] = None): Option[Transaction] = {
    val await = Try(Await.result(userRequestWithdrawalAsync(currency, amount, otpToken, address, addressId, targetUserId, fee, text), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Request a withdrawal to an external wallet. asynchronously
   * This will send a confirmation email to the email address on record.
   *
   * @param currency Currency you&#39;re withdrawing. Options: &#x60;XBt&#x60;, &#x60;USDt&#x60; 
   * @param amount Amount of withdrawal currency. 
   * @param otpToken 2FA token. Required for all external withdrawals. (optional)
   * @param address Destination Address. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param addressId ID of the Destination Address. One of &#x60;address&#x60;, &#x60;targetUserId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param targetUserId ID of the Target User. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param fee Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email. (optional)
   * @param text Optional annotation, e.g. &#39;Transfer to home wallet&#39;. (optional)
   * @return Future(Transaction)
   */
  def userRequestWithdrawalAsync(currency: String = "XBt", amount: Number, otpToken: Option[String] = None, address: Option[String] = None, addressId: Option[Double] = None, targetUserId: Option[Double] = None, fee: Option[Double] = None, text: Option[String] = None): Future[Transaction] = {
      helper.userRequestWithdrawal(currency, amount, otpToken, address, addressId, targetUserId, fee, text)
  }

  /**
   * Save user preferences.
   * 
   *
   * @param prefs  
   * @param overwrite If true, will overwrite all existing preferences. (optional, default to false)
   * @return User
   */
  def userSavePreferences(prefs: String, overwrite: Option[Boolean] = Option(false)): Option[User] = {
    val await = Try(Await.result(userSavePreferencesAsync(prefs, overwrite), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Save user preferences. asynchronously
   * 
   *
   * @param prefs  
   * @param overwrite If true, will overwrite all existing preferences. (optional, default to false)
   * @return Future(User)
   */
  def userSavePreferencesAsync(prefs: String, overwrite: Option[Boolean] = Option(false)): Future[User] = {
      helper.userSavePreferences(prefs, overwrite)
  }

}

class UserApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def userCancelWithdrawal(token: String)(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/cancelWithdrawal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userCancelWithdrawal")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCheckReferralCode(referralCode: Option[String] = None
    )(implicit reader: ClientResponseReader[Double]): Future[Double] = {
    // create path and map variables
    val path = (addFmt("/user/checkReferralCode"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    referralCode match {
      case Some(param) => queryParams += "referralCode" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCommunicationToken(token: String,
    platformAgent: String)(implicit reader: ClientResponseReader[List[CommunicationToken]]): Future[List[CommunicationToken]] = {
    // create path and map variables
    val path = (addFmt("/user/communicationToken"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userCommunicationToken")

    if (platformAgent == null) throw new Exception("Missing required parameter 'platformAgent' when calling UserApi->userCommunicationToken")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userConfirm(token: String)(implicit reader: ClientResponseReader[AccessToken]): Future[AccessToken] = {
    // create path and map variables
    val path = (addFmt("/user/confirmEmail"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userConfirm")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userConfirmWithdrawal(token: String)(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/confirmWithdrawal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userConfirmWithdrawal")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGet()(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetAffiliateStatus(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[Affiliate]): Future[Affiliate] = {
    // create path and map variables
    val path = (addFmt("/user/affiliateStatus"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetCommission()(implicit reader: ClientResponseReader[UserCommissionsBySymbol]): Future[UserCommissionsBySymbol] = {
    // create path and map variables
    val path = (addFmt("/user/commission"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetDepositAddress(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/user/depositAddress"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetExecutionHistory(symbol: String = "XBTUSD",
    timestamp: Date = dateTimeFormatter.parse("2017-02-13T12:00:00.000Z"))(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/executionHistory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (symbol == null) throw new Exception("Missing required parameter 'symbol' when calling UserApi->userGetExecutionHistory")

    queryParams += "symbol" -> symbol.toString
    queryParams += "timestamp" -> timestamp.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetMargin(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[Margin]): Future[Margin] = {
    // create path and map variables
    val path = (addFmt("/user/margin"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetQuoteFillRatio()(implicit reader: ClientResponseReader[QuoteFillRatio]): Future[QuoteFillRatio] = {
    // create path and map variables
    val path = (addFmt("/user/quoteFillRatio"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetQuoteValueRatio()(implicit reader: ClientResponseReader[QuoteValueRatio]): Future[QuoteValueRatio] = {
    // create path and map variables
    val path = (addFmt("/user/quoteValueRatio"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetTradingVolume()(implicit reader: ClientResponseReader[TradingVolume]): Future[TradingVolume] = {
    // create path and map variables
    val path = (addFmt("/user/tradingVolume"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWallet(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[Wallet]): Future[Wallet] = {
    // create path and map variables
    val path = (addFmt("/user/wallet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWalletHistory(currency: Option[String] = Option("XBt"),
    count: Option[Double] = Option(100),
    start: Option[Double] = Option(0)
    )(implicit reader: ClientResponseReader[List[Transaction]]): Future[List[Transaction]] = {
    // create path and map variables
    val path = (addFmt("/user/walletHistory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }
    count match {
      case Some(param) => queryParams += "count" -> param.toString
      case _ => queryParams
    }
    start match {
      case Some(param) => queryParams += "start" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWalletSummary(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[List[Transaction]]): Future[List[Transaction]] = {
    // create path and map variables
    val path = (addFmt("/user/walletSummary"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userLogout()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/user/logout"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userMinWithdrawalFee(currency: Option[String] = Option("XBt"),
    amount: Option[Double] = None
    )(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/minWithdrawalFee"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }
    amount match {
      case Some(param) => queryParams += "amount" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userRequestWithdrawal(currency: String = "XBt",
    amount: Number,
    otpToken: Option[String] = None,
    address: Option[String] = None,
    addressId: Option[Double] = None,
    targetUserId: Option[Double] = None,
    fee: Option[Double] = None,
    text: Option[String] = None
    )(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/requestWithdrawal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (currency == null) throw new Exception("Missing required parameter 'currency' when calling UserApi->userRequestWithdrawal")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userSavePreferences(prefs: String,
    overwrite: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user/preferences"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (prefs == null) throw new Exception("Missing required parameter 'prefs' when calling UserApi->userSavePreferences")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
